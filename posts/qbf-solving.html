<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Daniel Waterworth">
  <meta name="dcterms.date" content="2016-07-22">
  <title>QBF Solving</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./../css/main.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<header>
<h1 class="title">QBF Solving</h1>
<h2 class="author">Daniel Waterworth</h2>
<h3 class="date">July 22, 2016</h3>
</header>
<h2 id="what-is-qbf-solving">What is QBF solving?</h2>
<blockquote>
<figure>
<img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" />
</figure>
</blockquote>
<blockquote>
<p><em><a href="https://xkcd.com/399/">travelling salesman problem - xkcd 399</a></em></p>
</blockquote>
<p>If you are a programmer, it is likely that you have at least a vague understanding of what an <a href="https://en.wikipedia.org/wiki/NP-complete">NP-complete</a> problem is; even if it’s just, “those really hard ones”.</p>
<p>What you may not know, is that, although NP-complete problems are difficult in general, a significant proportion of them are easy in practice and there are tools, called SAT solvers, that can efficiently solve this subset.</p>
<p>SAT solvers allow you to ask questions like, “does there exist an x such that y is true?”. This is incredibly useful for hardware or software verification since you can effectively ask, “is there an input that causes this invariant to break?”.</p>
<p>However, there are caveats. Since SAT solvers attempt to solve the <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT problem</a>, it must be possible to translate your problem into a <a href="https://en.wikipedia.org/wiki/Propositional_formula">propositional expression</a>. In practice this means that you can only verify properties about programs that don’t have loops or hardware that forms <a href="https://en.wikipedia.org/wiki/Combinational_logic">combinational circuits</a>. (If you unroll your loops up to some fixed bound, you are doing <a href="https://en.wikipedia.org/wiki/Model_checking">bounded model checking</a>).</p>
<p>Another limitation is that, although you can pose questions like, “does there exist an x such that y is true?” or “for all x is y true?”, you can’t ask questions like “does there exist an x such that for all y, z is true?”.</p>
<p>It turns out, although NP-complete problems are hard, there are more difficult classes of problems.</p>
<figure>
<img src="../images/thinking.png" />
</figure>
<h2 id="puzzles-vs-games">Puzzles vs Games</h2>
<p>There is an interesting trend amongst the kinds of puzzles that people like to solve. Many of them are <a href="https://en.wikipedia.org/wiki/List_of_NP-complete_problems#Games_and_puzzles">NP-complete</a>, and conversely many NP-complete problems can be made into interesting puzzles.</p>
<p>In the same manner, many two-player games are <a href="https://en.wikipedia.org/wiki/PSPACE-complete">PSPACE-complete</a>. PSPACE is the class of problems that can be solved using polynomial space and PSPACE-complete problems are the hardest problems in PSPACE. PSPACE contains NP, so it is more difficult.</p>
<p>Just as the canonical NP-complete problem is SAT, the canonical PSPACE-complete problem is <a href="https://en.wikipedia.org/wiki/True_quantified_Boolean_formula">QBF</a> and so a QBF solver is a tool to help you win two-player games (with caveats).</p>
<p>QBF has the same limitation as SAT in that, we still can’t express loops, so our two-players games must have a polynomial number of turns. In other words, we can devise strategies for tick-tack-toe, but not chess.</p>
<p>PSPACE problems are hard, but there are yet more difficult classes of problems. For example, chess belongs to a class called <a href="https://en.wikipedia.org/wiki/EXPTIME-complete">EXPTIME-complete</a>.</p>
<h2 id="back-to-reality">Back to reality</h2>
<p>Whilst SAT solvers have been widely adopted for real problems, QBF solvers have not. Progress is being made, but we simply don’t yet have QBF solvers that work effectively on large problems.</p>
<p>This is a shame since, if we did, we could do things like program synthesis; “does there exist a program, such that for all inputs, these invariants hold?”.</p>
<p>For my part, I’ve have been writing <a href="https://github.com/DanielWaterworth/qbf-rust">my own solver</a>, which I hope to blog more about in the future.</p>
</body>
</html>
